**УКРАЇНСЬКИЙ КАТОЛИЦЬКИЙ УНІВЕРСИТЕТ**

**ФАКУЛЬТЕТ ПРИКЛАДНИХ НАУК**

**Комп'ютерні науки**

![ucu-cs-logo](images/ucu_cs_logo.png)

1 червня 2020 року

*@ Міщенко Ярема*

# Dijkstra Algorithm

Цей проект реалізує алгоритм Дейкстри знаходження найкоротшого
шляху між двома вершинами графу.

Цей проект використовує знання теорії графів, термінологію графів, а також вміння реалізувати граф мовою програмування.

Проект є прямою інтерпретацією алгоритму Дейкстри на мові C++.

## Технічні характеристики

Мова - С++

Компілятор - gcc-c++

Часова складність - O((N + M) * logN), де N - кількість вершин, а M - кількість ребер графу.
Це може означати різні речі. В тісно заповненому графі, де M ~ N^2, складність наближається до O(N^2 * logN).
А от в розрідженому графі, де M ~ N, складність - O(N * logN).

Просторова складність - O(N + M) - розмір списку суміжності. Знову ж таки, за аналогією ця складність може мінятись
від O(N) до O(N^2) в залежності від типу графу.

## Псевдокод

Програма поділяється на дві частини.

- Ввід графу для роботи алгоритму.
Для того, щоб можна було використати алгоритм Дейкстри, спочатку потрібно збудувати граф.
Це я роблю за допомогою численних інпутів в юзера:
    ![input-example](images/input-image.png)
Таким чином, я створюю список суміжності графа, а потім заповнюю кожне ребро по черзі.


## Висновки

Цей проект був цікавим і пізнавальним. Я не тільки краще зрозумів, як працює алгоритм Дейкстри,
але і навчився краще писати код на С++. Тепер, коли я власноруч імплементував алгоритм,
буде не тяжко його написати ще раз, коли це буде необхідно, тому цей проект мав і практичне значення для мене.

Найважливіше - я зрозумів, як складно писати чіткі і зрозумілі коментарі, щоб інші могли читати твій код :D

## Додаткова інформація

### Використання

Для запуску програми можна використати один з наступних варіантів:
1. Запустити через середовище. Наприклад, в CLion IDE ви можете створити проект,
скопіювати код в файл `main.cpp`, і тоді запустити проект.
2. Створити `.exe` файл, який виконується при відкритті, за допомогою компілятора C++.
Наприклад, якщо у вас встановлений компілятор gcc-c++/g++, виконайте

        g++ main.cpp -o dijkstra_algorithm

    в папці, в яку ви скачали файл `main.cpp`, і в тій папці з'явиться `dijkstra_algorithm.exe`.
Відкрийте цей файл, і програма запуститься.
3. Використати онлайн-компілятор C++
    1. [repl.it](https://repl.it/languages/cpp)
    2. [cpp.sh](http://cpp.sh/)
    3. [onlinegdb.com](https://www.onlinegdb.com/online_c++_compiler)
    
    Роботу з цими програмами вам доведеться освоїти без мене.

### Ініціалізація графу

В алгоритм входить також і створення графу. Для тесту пропоную використати такий граф,
з даною початковою та кінцевою вершиною.

---

![graph](images/test_graph.jpg)

---

В даному графі ми намагаємось проїхати від Львова - 1 до Одеси - 7 (абстракція)

Правильна дорога позначена справа.

Інпут для цього графу (просто скопіюйте без лапок):

> "13 18 0 1 7 0 10 3 0 11 4 1 10 2 1 2 3 2 3 2 3 4 4 3 5 4 4 5 6 4 6 4 5 6 4 6 7 5 7 8 2 8 9 2 9 12 3 9 10 1 10 11 4 11 12 5"

Цей ввід еквівалентний графу з фотографії.
В С++ можна ввести всі інпути за раз, через пробіли, і тоді вони всі заповняться зразу.
Потім треба ввести початкову і кінцеву вершину, в даному випадку це 1 (Львів) та 7 (Одеса).
Можете вибрати свої.

Ремарка: якщо вводити все одночасно, тексти вводу з'являться всі одночасно, невідформатовані. Це нормально.

### Вивід

За даними з попереднього розділу, ви маєте отримати такий текст на виході:

    Shortest path from 1 to 7 found!
    1->10->9->8->7
    
    Program done. Type 'quit' to end execution.

Якщо вивід не такий - алгоритм зламався. Але такого не має бути.