#include <iostream>
#include <vector>
#include <utility>
#include <set>
#include <limits>
#include <algorithm>


// СИНТАКСИС
// std::cin - аналог input()
// std::cout - аналог print()
// std::endl - аналог \n
// for (int i = 0; i < n; ++i) - аналог for i in range(n)
// for (auto & test: tests) - аналог for test in tests

// ТИПИ ДАНИХ
// std::vector - це просто аналог list у Python. Тільки треба позначати який тип буде зберігатись в ньому у <type>
// std::pair - vector з двох елементів зі спрощеним інтерфейсом. Елементи не обов'язково однакового типу,
// тому позначаємо тип обох.
// В цій програмі замість того щоб писати std::pair<int, int>, будемо писати intpair. Це просто скорочення.
typedef std::pair<int, int> intpair;
// std::set - як set у Python, але завжди відсортований. Ми його використовуємо як пріоритетну чергу.

// Також, std:: - просто означає що ця річ зі стандартної бібліотеки C++.
// Не варто звертати на це увагу.


// Створюємо псевдо-нескінченність для алгоритму Дейкстри.
// Насправді це створює найбільше можливе ціле число в C++.
const int infinity = std::numeric_limits<int>::max();

// C++ не любить створювати масиви з динамічним розміром.
// Тому припустимо, що максимальна к-сть вершин графа - 100, і будемо створювати масиви розміру 1000.
const int MAXN = 1e4;


std::vector<int> dijkstra() {
    // Для початку потрібно збудувати граф. Цей процес описаний в README.md

    // Отримуємо кількість вершин графа.
    int n;
    std::cout << "Enter the number of vertices: ";
    std::cin >> n;
    // Отримуємо кількість ребер графа. (це для зручного заповнення списку суміжності)
    int m;
    std::cout << "Enter the number of edges: ";
    std::cin >> m;

    // Будуємо список суміжності позначення графа.
    // Довжина - кількість вершин.
    // Вершини ми будемо називати просто за їх індексом - це дозволяє доступатись за індексом а не складними назвами.
    // В кожній позиції списку інформація про цю вершину, а саме список ребер, які виходять з цієї вершини.
    // Ребро позначається парою.
    // В парі - номер вершини, до якої йде ребро (індекс), а також вага цього ребра (ціле число).

    // В C++ щоб створити масив довжини n треба спочатку написати який тип він буде містити - в нашому
    // випадку список пар цілих чисел (пояснено вище), тоді назву масиву, а тоді його величину (n)
    std::vector<intpair> adjList[MAXN];

    // Заповнюємо список суміжності. По черзі кожне ребро.
    std::cout << "Filling the edges." << std::endl;
    for(int i = 0; i < m; ++i) {
        // Користувач вводить три параметри для ребра: одну вершину, другу вершину, та вагу ребра
        int ver1, ver2, weight;
        std::cout << "Enter the vertices and the weight of edge " << i << " (all separated by a space): ";
        std::cin >> ver1 >> ver2 >> weight;

        // Повіримо, що користувач ввів правильні числа (вершини від 0 до n-1, вага додатня, без повторів)
        // Тоді в наш список закидуємо дві речі - в першу вершину пару (вага, друга вершина),
        // а в другу вершину пару (вага, перша вершина)
        // Таким чином, обидві вершини знають, що вони з'єднані ребром ваги weight.
        adjList[ver1].emplace_back(weight, ver2);
        adjList[ver2].emplace_back(weight, ver1);
    }

    // Список суміжності готовий. Розпочинаємо сам АЛГОРИТМ ДЕЙКСТРИ.

    // Отримуємо початкову вершину.
    int s;
    std::cout << "Enter the starting vertex (0 to " << n - 1 << "): ";
    std::cin >> s;
    // Отримуємо кінцеву вершину.
    int e;
    std::cout << "Enter the ending vertex (0 to " << n - 1 << "): ";
    std::cin >> e;

    // Тут будемо зберігати пари (відстань до вершини, індекс вершини).
    // std::set сортує пари по першому члену (відстань), тому першим елементом черги завжди буде найближча вершина.
    // Для початку в чергу додаємо лише початкову вершину з відстанню 0.
    std::set<intpair> priority_queue;
    priority_queue.emplace(0, s);

    // Тут будемо позначати відстань до кожної вершини.
    // Заповнюємо "нескінченністю", крім початкової вершини, до якої відстань 0.
    int distance[MAXN];
    std::fill_n(distance, n, infinity);
    distance[s] = 0;

    // Тут будемо позначати звідки ми прийшли до кожної вершини.
    // Таким чином, в кінці зможемо відбудувати шлях.
    // Заповнюємо -1. -1 означає що в даної вершини поки що немає предка, тобто алгоритм ще не знайшов цю вершину.
    int parent[MAXN];
    std::fill_n(parent, n, -1);

    // Розпочинаємо ітерацію по вершинам. На всякий випадок (хоча такого не має статись), зупиняємо коли черга пуста.
    while (!priority_queue.empty()) {

        // Витягуємо перший елемент з сету distance - завдяки сортуванню сетів він має найменшу відстань.
        intpair current_vertex = *priority_queue.begin();
        priority_queue.erase(priority_queue.begin());
        int cur_distance = current_vertex.first;
        int cur_idx = current_vertex.second;

        // Виходимо з петлі тоді, коли вершина в даній ітерації == кінцева вершина,
        // АБО коли доходимо до вершини, відстань до якої - "нескінченність".
        // Таке може статись тільки тоді, коли дана вершина в іншій компоненті, ніж початкова,
        // тобто зв'язку між ними взагалі немає.
        if (cur_idx == e || cur_distance == infinity) break;

        // Дістаємо список ребер, які виходять з даної вершини.
        std::vector<intpair> cur_edges = adjList[cur_idx];
        // Ітеруємося по ребрах.
        for (auto & cur_edge : cur_edges) {
            int edge_to = cur_edge.second;
            int edge_weight = cur_edge.first;

            // Якщо дорога через cur_idx коротша ніж теперішня відстань до edge_to, тоді ...
            if (distance[cur_idx] + edge_weight < distance[edge_to]) {

                // ... в priority_queue додаємо edge_to вже з новою відстанню.

                // Якщо відстань до edge_to скінченна величина - значить edge_to вже є в черзі,
                // тому треба спочатку видалити з черги старе входження edge_to.
                if (distance[edge_to] != infinity) {
                    priority_queue.erase(priority_queue.find(std::make_pair(distance[edge_to], edge_to)));
                }
                // А тоді додаємо в чергу вже нове входження edge_to, з меншою відстанню.
                priority_queue.emplace(distance[cur_idx] + edge_weight, edge_to);

                // Також замінюємо відстань до edge_to на нову, меншу.
                distance[edge_to] = distance[cur_idx] + edge_weight;

                // І встановлюємо cur_idx як батька edge_to.
                parent[edge_to] = cur_idx;
            }
        }
    }

    // Якщо ми дойшли сюди, це означає що while закінчився.
    // Ми могли вийти на одній з трьох умов, але нам треба саме та, що ми дойшли до кінцевої вершини.
    // Перевіряємо це тим, що у кінцевої вершини має бути предок.
    if (parent[e] != -1) {
        // Дорога є.
        std::cout << std::endl <<  std::endl << "Shortest path from " << s << " to " << e << " found!" << std::endl;

        // Щоб визначити дорогу, потрібно пройтись по parent у зворотньому порядку,
        // починаючи з кінцевої вершини і поки не дійдемо до початкової.
        // Тоді розвернути дорогу.

        // Створюємо список, куди будемо вставляти елементи дороги.
        std::vector<int> s_to_e;

        // В for loop починаємо з кінцевої вершини, йдемо поки теперішня вершина не буде початковою,
        // і кожного разу міняємо теперішню вершину на її предка.
        for (int v = e; v != s; v =parent[v]) s_to_e.push_back(v);

        // Додаємо початкову вершину (ми її не врахували)
        s_to_e.push_back(s);

        // Нарешті, розвертаємо дорогу - ми йшли з кінця.
        reverse(s_to_e.begin(), s_to_e.end());

        return s_to_e;
    } else {
        // Дороги немає, значить граф має більше ніж одну компоненту,
        // або взагалі неправильно заданий.
        std::cout << std::endl << std::endl << "Path not found. Make sure your graph is valid and only contains one component." << std::endl;
        std::vector<int> error;
        for (int i = 0; i < n; ++i) {
            error.push_back(-1);
        }
        return error;
    }
}

// Саме тут, в функції main проходить виконання програми.
int main() {
    // Викликаємо алгоритм Дейкстри (описаний в функції вище)
    // На рахунок правильного вводу читайте README.md
    std::vector<int> shortest_path = dijkstra();

    // Алгоритм повертає список вершин, через які проходить дорога.
    // Ітеруємось по списку і друкуємо вершини.
    for (int i = 0; i < shortest_path.size() - 1; ++i) {
        std::cout << shortest_path[i] << "->";
    } std::cout << shortest_path[shortest_path.size() - 1];

    // Програма закінчена.
    std::cout << std::endl << std::endl << "Program done. Type 'quit' to end execution." << std::endl;

    // Оскільки .exe закривається, як тільки закінчується робота, додамо в кінці інпут.
    // Програма закінчиться тільки тоді, коли ви введете "quit"
    std::string quit;
    while (true) {
        std::cin >> quit;
        if (quit == "quit") break;
    }

    // В С та С++ треба традиційно повертати 0 в кінці основної програми.
    // Комп'ютер сприймає це як "робота програми пройшла без проблем".
    return 0;
}
